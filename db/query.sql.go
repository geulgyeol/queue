// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
)

const deleteContentQueueItems = `-- name: DeleteContentQueueItems :execrows
DELETE FROM content_queue
WHERE id = ANY($1::bigint[]) AND status = 'processing'
`

func (q *Queries) DeleteContentQueueItems(ctx context.Context, arr []int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteContentQueueItems, arr)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProfileQueueItems = `-- name: DeleteProfileQueueItems :execrows

DELETE FROM profile_queue
WHERE id = ANY($1::bigint[]) AND status = 'processing'
`

// ensure only processing items are deleted
func (q *Queries) DeleteProfileQueueItems(ctx context.Context, arr []int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProfileQueueItems, arr)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteUserQueueItems = `-- name: DeleteUserQueueItems :execrows

DELETE FROM user_queue
WHERE id = ANY($1::bigint[]) AND status = 'processing'
`

// ensure only processing items are deleted
func (q *Queries) DeleteUserQueueItems(ctx context.Context, arr []int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteUserQueueItems, arr)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const popContentQueueItems = `-- name: PopContentQueueItems :many
WITH cte AS (
    SELECT id
    FROM content_queue
    WHERE content_queue.attempts <= $1
      AND (
        (status = 'waiting' AND (locked_until IS NULL OR locked_until < now()))
        OR (status = 'processing' AND locked_until < now())
      )
    ORDER BY enqueued_at
    LIMIT $2
    FOR UPDATE SKIP LOCKED
)
UPDATE content_queue q
SET status = 'processing',
    locked_until = now() + interval '120 seconds',
    attempts = attempts + 1
FROM cte
WHERE q.id = cte.id
    RETURNING q.id, q.payload, q.enqueued_at, q.locked_until, q.attempts, q.status
`

type PopContentQueueItemsParams struct {
	Attempts int32 `json:"attempts"`
	Limit    int32 `json:"limit"`
}

func (q *Queries) PopContentQueueItems(ctx context.Context, arg PopContentQueueItemsParams) ([]ContentQueue, error) {
	rows, err := q.db.Query(ctx, popContentQueueItems, arg.Attempts, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentQueue
	for rows.Next() {
		var i ContentQueue
		if err := rows.Scan(
			&i.ID,
			&i.Payload,
			&i.EnqueuedAt,
			&i.LockedUntil,
			&i.Attempts,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popProfileQueueItems = `-- name: PopProfileQueueItems :many
WITH cte AS (
    SELECT id
    FROM profile_queue
    WHERE profile_queue.attempts <= $1
      AND (
        (status = 'waiting' AND (locked_until IS NULL OR locked_until < now()))
        OR (status = 'processing' AND locked_until < now())
      )
    ORDER BY enqueued_at
    LIMIT $2
    FOR UPDATE SKIP LOCKED
            )
UPDATE profile_queue q
SET status = 'processing',
    locked_until = now() + interval '120 seconds',
    attempts = attempts + 1
FROM cte
WHERE q.id = cte.id
    RETURNING q.id, q.payload, q.enqueued_at, q.locked_until, q.attempts, q.status
`

type PopProfileQueueItemsParams struct {
	Attempts int32 `json:"attempts"`
	Limit    int32 `json:"limit"`
}

func (q *Queries) PopProfileQueueItems(ctx context.Context, arg PopProfileQueueItemsParams) ([]ProfileQueue, error) {
	rows, err := q.db.Query(ctx, popProfileQueueItems, arg.Attempts, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfileQueue
	for rows.Next() {
		var i ProfileQueue
		if err := rows.Scan(
			&i.ID,
			&i.Payload,
			&i.EnqueuedAt,
			&i.LockedUntil,
			&i.Attempts,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popUserQueueItems = `-- name: PopUserQueueItems :many
WITH cte AS (
    SELECT id
    FROM user_queue
    WHERE user_queue.attempts <= $1
      AND (
        (status = 'waiting' AND (locked_until IS NULL OR locked_until < now()))
        OR (status = 'processing' AND locked_until < now())
      )
    ORDER BY enqueued_at
    LIMIT $2
    FOR UPDATE SKIP LOCKED
)
UPDATE user_queue q
SET status = 'processing',
    locked_until = now() + interval '120 seconds',
    attempts = attempts + 1
FROM cte
WHERE q.id = cte.id
    RETURNING q.id, q.payload, q.enqueued_at, q.locked_until, q.attempts, q.status
`

type PopUserQueueItemsParams struct {
	Attempts int32 `json:"attempts"`
	Limit    int32 `json:"limit"`
}

func (q *Queries) PopUserQueueItems(ctx context.Context, arg PopUserQueueItemsParams) ([]UserQueue, error) {
	rows, err := q.db.Query(ctx, popUserQueueItems, arg.Attempts, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserQueue
	for rows.Next() {
		var i UserQueue
		if err := rows.Scan(
			&i.ID,
			&i.Payload,
			&i.EnqueuedAt,
			&i.LockedUntil,
			&i.Attempts,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
