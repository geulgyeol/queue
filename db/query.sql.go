// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
)

const enqueueContentItem = `-- name: EnqueueContentItem :one
INSERT INTO content_queue (payload)
VALUES ($1)
RETURNING id, payload, enqueued_at, locked_until, attempts, status
`

func (q *Queries) EnqueueContentItem(ctx context.Context, payload string) (ContentQueue, error) {
	row := q.db.QueryRow(ctx, enqueueContentItem, payload)
	var i ContentQueue
	err := row.Scan(
		&i.ID,
		&i.Payload,
		&i.EnqueuedAt,
		&i.LockedUntil,
		&i.Attempts,
		&i.Status,
	)
	return i, err
}

const popContentQueueItems = `-- name: PopContentQueueItems :many
WITH cte AS (
    SELECT id
    FROM content_queue
    WHERE content_queue.attempts <= $1
      AND (
        (status = 'waiting' AND (locked_until IS NULL OR locked_until < now()))
        OR (status = 'processing' AND locked_until < now())
      )
    ORDER BY enqueued_at
    LIMIT $2
    FOR UPDATE SKIP LOCKED
)
UPDATE content_queue q
SET status = 'processing',
    locked_until = now() + interval '120 seconds',
    attempts = attempts + 1
FROM cte
WHERE q.id = cte.id
    RETURNING q.id, q.payload, q.enqueued_at, q.locked_until, q.attempts, q.status
`

type PopContentQueueItemsParams struct {
	Attempts int32
	Limit    int32
}

func (q *Queries) PopContentQueueItems(ctx context.Context, arg PopContentQueueItemsParams) ([]ContentQueue, error) {
	rows, err := q.db.Query(ctx, popContentQueueItems, arg.Attempts, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentQueue
	for rows.Next() {
		var i ContentQueue
		if err := rows.Scan(
			&i.ID,
			&i.Payload,
			&i.EnqueuedAt,
			&i.LockedUntil,
			&i.Attempts,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popProfileQueueItems = `-- name: PopProfileQueueItems :many
WITH cte AS (
    SELECT id
    FROM profile_queue
    WHERE profile_queue.attempts <= $1
      AND (
        (status = 'waiting' AND (locked_until IS NULL OR locked_until < now()))
        OR (status = 'processing' AND locked_until < now())
      )
    ORDER BY enqueued_at
    LIMIT $2
    FOR UPDATE SKIP LOCKED
            )
UPDATE profile_queue q
SET status = 'processing',
    locked_until = now() + interval '120 seconds',
    attempts = attempts + 1
FROM cte
WHERE q.id = cte.id
    RETURNING q.id, q.payload, q.enqueued_at, q.locked_until, q.attempts, q.status
`

type PopProfileQueueItemsParams struct {
	Attempts int32
	Limit    int32
}

func (q *Queries) PopProfileQueueItems(ctx context.Context, arg PopProfileQueueItemsParams) ([]ProfileQueue, error) {
	rows, err := q.db.Query(ctx, popProfileQueueItems, arg.Attempts, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfileQueue
	for rows.Next() {
		var i ProfileQueue
		if err := rows.Scan(
			&i.ID,
			&i.Payload,
			&i.EnqueuedAt,
			&i.LockedUntil,
			&i.Attempts,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popUserQueueItems = `-- name: PopUserQueueItems :many
WITH cte AS (
    SELECT id
    FROM user_queue
    WHERE user_queue.attempts <= $1
      AND (
        (status = 'waiting' AND (locked_until IS NULL OR locked_until < now()))
        OR (status = 'processing' AND locked_until < now())
      )
    ORDER BY enqueued_at
    LIMIT $2
    FOR UPDATE SKIP LOCKED
)
UPDATE user_queue q
SET status = 'processing',
    locked_until = now() + interval '120 seconds',
    attempts = attempts + 1
FROM cte
WHERE q.id = cte.id
    RETURNING q.id, q.payload, q.enqueued_at, q.locked_until, q.attempts, q.status
`

type PopUserQueueItemsParams struct {
	Attempts int32
	Limit    int32
}

func (q *Queries) PopUserQueueItems(ctx context.Context, arg PopUserQueueItemsParams) ([]UserQueue, error) {
	rows, err := q.db.Query(ctx, popUserQueueItems, arg.Attempts, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserQueue
	for rows.Next() {
		var i UserQueue
		if err := rows.Scan(
			&i.ID,
			&i.Payload,
			&i.EnqueuedAt,
			&i.LockedUntil,
			&i.Attempts,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
